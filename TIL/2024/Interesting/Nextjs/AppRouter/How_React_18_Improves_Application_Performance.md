# How React 18 Improves Application Performance

2023 年 7 月 19 日に投稿された Blog 記事を翻訳しながら、React 18 について理解していきます。

React 18 では React アプリのレンダリングされる方法を根本的に変える機能が導入されました

- まずは長いタスクの基本とそれに対するパフォーマンスの計測値を理解しましょう。

## Main thread and Long Task

- ブラウザで JavaScript を実行すると JavaScript エンジンはシングルスレットの環境(メインスレッドと呼ばれることが多い)でコードを実行します。

  - メインスレッドは 1 つずつタスクを処理する責任があります。
    - Parsing HTML → Layout → Paint → User Interaction→ Pain → User Interraction...
  - メインスレッドは以下のタスクの処理も担当します。
    - クリックやキーストロークのようなユーザーインタラクションの管理
    - ネットワークイベントや時間の処理
    - アニメーションの更新
    - ブラウザのリフローと再描画の管理など

- タスクを 1 つ処理している時には他のタスクは全て待ちの状態になっている

  - 小さなタスクはブラウザがスムーズに実行して、シームレスな UX を提供できる
  - 長いタスクは他のタスクの処理をブロックする可能性があるため、問題が起こりやすい
  - 50 ミリ秒を超えるタスクは「長いタスク」とみなされる
    - 50 ミリ秒の数値はスムーズな視覚体験を維持するためにデバイスが 16 ミリ秒(60fps)ごとに新しいフレームを作成する必要がある事実に基づいている
    - ただし、デバイスはユーザー入力への応答や JavaScript の実行など他のタスクも実行する必要がある
    - デバイスはフレームのレンダリングと他のタスクの実行にリソースを割り当てることができ、スムーズな視覚的体験を維持しながら他のタスクを実行ために~33.33 ミリ秒を追加で提供されます
    - 詳しくはこちら「[RAIL モデルでパフォーマンスを測定する](https://web.dev/articles/rail?hl=ja#response-process-events-in-under-50ms)」

- 最適なパフォーマンスを維持するには長いタスクの数を最小限に抑えることが必要

  - Web サイトのパフォーマンスを計測するには、Web アプリのパフォーマンスに対する長いタスクの影響を測定する必要がある
  - 2 つの指標があります
    - Total Blockng Time(TBT)
      - First Contentful Paint(FCP)からインタラクティブまでの時間(Time to Interactive)を計測する重要な指標
      - 50 ミリ秒を超えるタスこの実行にかかった時間の合計であり、UX に大きな影響を与える可能性がある
    - Interaction to Next Paint(INP)
      - 新しい Core Web Vitals 指標である INP はページでのユーザーの初動(ボタンをクリックなど)からインタラクションが画面に表示されるまでの時間を測定します。
      - この指標は特に e コマースやメディアプラットフォームのようなユーザーやりとりが多いページで重要です。

React のアップデートがこれらの計測に合わせてどう最適化して UX を向上するかは React の従来の挙動を理解することが重要です

## Traditional React Rendering

- 今までの React のレンダリング

  - React での見たもの更新はレンダーフィーズとコミットフェーズの 2 段階に分かれている
  - React でのレンダーフェーズ : React 要素が既存の DOM と調整(比較)される純粋な計算フェーズ
    - このフェーズは「仮想 DOM」として知られており、React 要素の新しいツリーの作成を含みます。「仮想 DOM」は実際の DOM の軽量のメモリ表現のことを指す
    - レンダリングフェーズの間に、React は現在の DOM と新たな React コンポーネントツリー間の差異を計算し、必要な部分の更新を準備する
  - コミットフェーズ: レンダーフェーズの次に行なわれる。React はレンダリングフェーズ中に計算された更新をコミットフェーズで実際の DOM に適用する
    - 新しい React コンポーネントツリーをミラーリングするための DOM ノードの作成、更新、削除が含まれる

- 従来の同期的なレンダリングでは、React はコンポーネントツリー内の全ての要素に同じ優先順位を与えます
- 初期レンダリングや状態更新によって、コンポーネントツリーがレンダリングされたときに React は先に進み、単一の中断できないタスクでレンダリングします
- その後に 画面上のコンポーネントを視覚的に更新するために、DOM の更新を行います

- 同期レンダリングは「全てか無か」の操作であり、コンポーネントのレンダリングは開始したら必ず終わることが保証されています
- コンポーネントの複雑さに応じて、レンダリングフェーズが完了までに時間がかかる場合があります
- メインスレッドはこの時間の間はブロックされます。つまり React がレンダリングを完了して DOM にコミットするまで、アプリケーションを操作しようとするとユーザーは UI が応答しなくなることになります。

- React18 では、バックグラウンドで動作する新し同時レンダラーが導入されています。

  - このレンダラーは、特定のレンダーと非緊急としてマークするいくつか方法を公開します。
  - 優先度の低いコンポーネントをレンダリングするときに、React はメインスレッドに戻って重要なタスクをチェックします
    - その場合、React は 5 ミリ秒ごとにメインスレッドに戻って処理すべきタスクがあるかどうかを確認します
      - ユーザー入力やその時点での UX にとってより重要な別の React コンポーネントの状態更新のレンダリングなど
    - 継続的にメインスレッドに戻って確認することで、レンダリングを non-blocking にして、より重要なタスクに優先順位をつけることができます

- 毎回のレンダリングごとに単一の割り込み不可能なタスクを実行するのではなく、同時レンダラーは優先度の低いコンポーネントの(再)レンダリング中に 5 ミリ秒の感覚で制御をメインスレッドに戻します

  - それに加えて、同時レンダラーは結果をすぐにコミットせずにバックグラウンドでコンポーネントツリーの複数のバージョンを「同時に」レンダリングできます
  - 一方、同期レンダリングは「全てか無か」の計算ですが、同時レンダラーは React が 1 つまたは複数のコンポーネントツリのレンダリングを一時停止及び再開して、最適な UX を実現できます。

- React はユーザーインタラクションに基づいて現在のレンダリングを一時停止して、別の更新のレンダリングを優先します

  - 同時機能を使用して、React はユーザーインタラクションのような外部イベントに基づいてコンポーネントのレンダリングを一時停止及び再開できます

## Transition

<!-- TODO: Transitionの内容 -->

## React Server Component

- この時点では React Server Component は実験的な機能です

  - Next.js では使用されているのでこの内容を知っておくことが重要

- 従来は React は Web アプリをレンダリングするための主な方法を提供していました
  - 全てをクライアント上で完全にレンダリングする(Client Side Rendering)
  - サーバー上でコンポーネントツリーを HTML にレンダリングしたり、JavaScript バンドルを使用してこの静的 HTML をクライアントに送信して、クライアント側でコンポーネントをハイドレートすることができます(Server Side Rendering)
- **どちらのアプローチも同期的 React レンダラーはコンポーネントツリーがサーバー上で既に利用可能であったとしても、出荷された JavaScript バンドルを使用してクライアント側でコンポーネントツリーを再構築する必要があるという事実に依存しています。**

- **React Server Component を使用すると React はクライアントに実際にシリアライズしたコンポーネントツリーを送ります**
- クライアント側の React レンダラーはこの形式を理解して、HTML ファイルや JavaScript バンドルを送信することなく、それを使用して React コンポーネントツリーをパフォーマンス的に再構築します

  - この新しいレンダリングパターンは`react-server-dom-webpack/server's renderToPipeableStream`メソッドと`react-dom/client's createRoot`メソッドを組み合わせることによって使用できます

- デフォルトでは、React は React サーバー コンポーネントをハイドレートしません。コンポーネントは、ウィンドウ オブジェクトへのアクセスや useState や useEffect などのフックの使用など、クライアント側の対話機能を使用することは想定されていません。

  - クライアントに配布される JavaScript バンドルにコンポーネントとそのインポートを追加して対話型にするには、ファイルの先頭で「use client」バンドラー ディレクティブを使用します。
  - これにより、バンドラーにこのコンポーネントとそのインポートをクライアント バンドルに追加するように指示し、React にクライアント側でツリーをハイドレートして対話性を追加するように指示します。このようなコンポーネントはクライアント コンポーネントと呼ばれます。

- **クライアント コンポーネントを使用するときにバンドル サイズを最適化するかどうかは開発者の責任です。開発者は次の方法でこれを行うことができます。**
  - インタラクティブコンポーネントの最端ノードのみが「use client」ディレクティブを定義するようにします。これには、コンポーネントの分離が必要になる場合があります。
  - コンポーネント ツリーを直接インポートするのではなく、小道具として渡します。これにより、React はクライアント バンドルに追加せずに、子を React サーバー コンポーネントとしてレンダリングできるようになります。

## References

[How React 18 Improves Application Performance](https://vercel.com/blog/how-react-18-improves-application-performance)
