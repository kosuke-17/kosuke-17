# How React 18 Improves Application Performance

2023 年 7 月 19 日に投稿された Blog 記事を翻訳しながら、React 18 について理解していきます。

React 18 では React アプリのレンダリングされる方法を根本的に変える機能が導入されました

- まずは長いタスクの基本とそれに対するパフォーマンスの計測値を理解しましょう。

## Main thread and Long Task

- ブラウザで JavaScript を実行すると JavaScript エンジンはシングルスレットの環境(メインスレッドと呼ばれることが多い)でコードを実行します。

  - メインスレッドは 1 つずつタスクを処理する責任があります。
    - Parsing HTML → Layout → Paint → User Interaction→ Pain → User Interraction...
  - メインスレッドは以下のタスクの処理も担当します。
    - クリックやキーストロークのようなユーザーインタラクションの管理
    - ネットワークイベントや時間の処理
    - アニメーションの更新
    - ブラウザのリフローと再描画の管理など

- タスクを 1 つ処理している時には他のタスクは全て待ちの状態になっている

  - 小さなタスクはブラウザがスムーズに実行して、シームレスな UX を提供できる
  - 長いタスクは他のタスクの処理をブロックする可能性があるため、問題が起こりやすい
  - 50 ミリ秒を超えるタスクは「長いタスク」とみなされる
    - 50 ミリ秒の数値はスムーズな視覚体験を維持するためにデバイスが 16 ミリ秒(60fps)ごとに新しいフレームを作成する必要がある事実に基づいている
    - ただし、デバイスはユーザー入力への応答や JavaScript の実行など他のタスクも実行する必要がある
    - デバイスはフレームのレンダリングと他のタスクの実行にリソースを割り当てることができ、スムーズな視覚的体験を維持しながら他のタスクを実行ために~33.33 ミリ秒を追加で提供されます
    - 詳しくはこちら「[RAIL モデルでパフォーマンスを測定する](https://web.dev/articles/rail?hl=ja#response-process-events-in-under-50ms)」

- 最適なパフォーマンスを維持するには長いタスクの数を最小限に抑えることが必要

  - Web サイトのパフォーマンスを計測するには、Web アプリのパフォーマンスに対する長いタスクの影響を測定する必要がある
  - 2 つの指標があります
    - Total Blockng Time(TBT)
      - First Contentful Paint(FCP)からインタラクティブまでの時間(Time to Interactive)を計測する重要な指標
      - 50 ミリ秒を超えるタスこの実行にかかった時間の合計であり、UX に大きな影響を与える可能性がある
    - Interaction to Next Paint(INP)
      - 新しい Core Web Vitals 指標である INP はページでのユーザーの初動(ボタンをクリックなど)からインタラクションが画面に表示されるまでの時間を測定します。
      - この指標は特に e コマースやメディアプラットフォームのようなユーザーやりとりが多いページで重要です。

React のアップデートがこれらの計測に合わせてどう最適化して UX を向上するかは React の従来の挙動を理解することが重要です

## Traditional React Rendering

- 今までの React のレンダリング

  - React での見たもの更新はレンダーフィーズとコミットフェーズの 2 段階に分かれている
  - React でのレンダーフェーズ : React 要素が既存の DOM と調整(比較)される純粋な計算フェーズ
    - このフェーズは「仮想 DOM」として知られており、React 要素の新しいツリーの作成を含みます。「仮想 DOM」は実際の DOM の軽量のメモリ表現のことを指す
    - レンダリングフェーズの間に、React は現在の DOM と新たな React コンポーネントツリー間の差異を計算し、必要な部分の更新を準備する
  - コミットフェーズ: レンダーフェーズの次に行なわれる。React はレンダリングフェーズ中に計算された更新をコミットフェーズで実際の DOM に適用する
    - 新しい React コンポーネントツリーをミラーリングするための DOM ノードの作成、更新、削除が含まれる

- 従来の同期的なレンダリングでは、React はコンポーネントツリー内の全ての要素に同じ優先順位を与えます
- 初期レンダリングや状態更新によって、コンポーネントツリーがレンダリングされたときに React は先に進み、単一の中断できないタスクでレンダリングします
- その後に 画面上のコンポーネントを視覚的に更新するために、DOM の更新を行います

- 同期レンダリングは「全てか無か」の操作であり、コンポーネントのレンダリングは開始したら必ず終わることが保証されています
- コンポーネントの複雑さに応じて、レンダリングフェーズが完了までに時間がかかる場合があります
- メインスレッドはこの時間の間はブロックされます。つまり React がレンダリングを完了して DOM にコミットするまで、アプリケーションを操作しようとするとユーザーは UI が応答しなくなることになります。

- React18 では、バックグラウンドで動作する新し同時レンダラーが導入されています。

  - このレンダラーは、特定のレンダーと非緊急としてマークするいくつか方法を公開します。
  - 優先度の低いコンポーネントをレンダリングするときに、React はメインスレッドに戻って重要なタスクをチェックします
    - その場合、React は 5 ミリ秒ごとにメインスレッドに戻って処理すべきタスクがあるかどうかを確認します
      - ユーザー入力やその時点での UX にとってより重要な別の React コンポーネントの状態更新のレンダリングなど
    - 継続的にメインスレッドに戻って確認することで、レンダリングを non-blocking にして、より重要なタスクに優先順位をつけることができます

- 毎回のレンダリングごとに単一の割り込み不可能なタスクを実行するのではなく、同時レンダラーは優先度の低いコンポーネントの(再)レンダリング中に 5 ミリ秒の感覚で制御をメインスレッドに戻します

  - それに加えて、同時レンダラーは結果をすぐにコミットせずにバックグラウンドでコンポーネントツリーの複数のバージョンを「同時に」レンダリングできます
  - 一方、同期レンダリングは「全てか無か」の計算ですが、同時レンダラーは React が 1 つまたは複数のコンポーネントツリのレンダリングを一時停止及び再開して、最適な UX を実現できます。

- React はユーザーインタラクションに基づいて現在のレンダリングを一時停止して、別の更新のレンダリングを優先します

  - 同時機能を使用して、React はユーザーインタラクションのような外部イベントに基づいてコンポーネントのレンダリングを一時停止及び再開できます

## Transition

- useTransition Hook を用いて startTransition 関数を使うことで更新を non-urgent(非緊急ではない)としてマークすることができます

  - これは強力な新機能で 遷移として特定の状態更新をできたり、同期的にレンダリングされた場合に UX を混乱させる可能性のある視覚的な変更を引き起こす可能性があることを示しています
  - startTransition で状態更新をラップすることで、現在のユーザーのインタラクティブを保つために、より重要なタスクを優先するためにレンダリングを延期または中断しても問題がないことを React に伝えることができます

- トランジションがスタートすると、コンカレントなレンダーはバックグラウンドで新しい tree を準備します

  - 1 度レンダリングが完了すると、React スケジューラーが DOM を最適に更新して新しい状態を反映できるようになるまで結果がメモリに保持されます
  - この瞬間はブラウザがアイドル状態で、優先度の高いタスク(ユーザー操作など)が保留されていない時である可能性があります
  - 都市一覧のデモは transition の使用に最適です
  - キーボード操作ごとに searchQuery パラメータに渡される値を直接更新するのではなく(キーボード操作ごとに同期レンダリング呼び出しが行われてしまう)、状態を 2 つに分割し、searchQuery の状態更新を startTransition でラップすることができます

    - これは、状態の更新によってユーザーに混乱をもたらす可能性のある見た目の変更が発生する可能性があることを React に伝えます
    - 従って、React はすぐに変更をコミットせずにバックグラウンドで新しい状態を準備しながら、現在の UI をインタラクティブに維持しようとする必要があります。

  - 入力フィールドに入力をすると、キーボード操作の間で視覚的な遅延がなく、ユーザー入力はスムーズなままになります
    - これは入力フィールドが値として使用するテキストの状態が依然として同期的に更新されるために発生します
    - バックグラウンドでは、React はキーボード操作ごとに新しいツリーのレンダリングを開始します。だたし、これは全か無かの同期的なタスクではなく、React 現在の UI(古い状態を表示)が更なるユーザー入力に応答したままである間に、メモリ内にコンポーネントツリーの新しいバージョンの準備を開始します
  - パフォーマンスタブを見てみると、更新状態を startTransition でラップすると transition を使わない場合の実装のパフォーマンスグラフと比較して、長いタスクの数と総ブロック時間が大幅に減少しました

- トランジションは React のレンダリングモデルでの根本的な変更の一部であり、React が複数のバージョンの UI を同時にレンダリングし、異なるタスク間の優先順位を管理できるようになります
  - これにより、特に高頻度の更新や CPU 負荷の高いレンダリングを処理する場合に、よりスムーズで応答性の高い UX が実現します

## React Server Component

- この時点では React Server Component は実験的な機能です

  - Next.js では使用されているのでこの内容を知っておくことが重要

- 従来は React は Web アプリをレンダリングするための主な方法を提供していました
  - 全てをクライアント上で完全にレンダリングする(Client Side Rendering)
  - サーバー上でコンポーネントツリーを HTML にレンダリングしたり、JavaScript バンドルを使用してこの静的 HTML をクライアントに送信して、クライアント側でコンポーネントをハイドレートすることができます(Server Side Rendering)
- **どちらのアプローチも同期的 React レンダラーはコンポーネントツリーがサーバー上で既に利用可能であったとしても、出荷された JavaScript バンドルを使用してクライアント側でコンポーネントツリーを再構築する必要があるという事実に依存しています。**

- **React Server Component を使用すると React はクライアントに実際にシリアライズしたコンポーネントツリーを送ります**
- クライアント側の React レンダラーはこの形式を理解して、HTML ファイルや JavaScript バンドルを送信することなく、それを使用して React コンポーネントツリーをパフォーマンス的に再構築します

  - この新しいレンダリングパターンは`react-server-dom-webpack/server's renderToPipeableStream`メソッドと`react-dom/client's createRoot`メソッドを組み合わせることによって使用できます

- デフォルトでは、React は React サーバー コンポーネントをハイドレートしません。コンポーネントは、ウィンドウ オブジェクトへのアクセスや useState や useEffect などのフックの使用など、クライアント側の対話機能を使用することは想定されていません。

  - クライアントに配布される JavaScript バンドルにコンポーネントとそのインポートを追加して対話型にするには、ファイルの先頭で「use client」バンドラー ディレクティブを使用します。
  - これにより、バンドラーにこのコンポーネントとそのインポートをクライアント バンドルに追加するように指示し、React にクライアント側でツリーをハイドレートして対話性を追加するように指示します。このようなコンポーネントはクライアント コンポーネントと呼ばれます。

- **クライアント コンポーネントを使用するときにバンドル サイズを最適化するかどうかは開発者の責任です。開発者は次の方法でこれを行うことができます。**
  - インタラクティブコンポーネントの最端ノードのみが「use client」ディレクティブを定義するようにします。これには、コンポーネントの分離が必要になる場合があります。
  - コンポーネント ツリーを直接インポートするのではなく、小道具として渡します。これにより、React はクライアント バンドルに追加せずに、子を React サーバー コンポーネントとしてレンダリングできるようになります。

## Suspense

<!-- TODO: Suspenseの内容 -->

## Data Fetching

- データをフェッチし、結果を効率的にメモ化をするための新しい API も存在する
- React18 には、ラップされた関数呼び出しの結果を記憶するキャッシュ関数が追加されました
  - 同じレンダーパス内で、同じ引数を使用して同じ関数を呼び出すと、関数を再実行することなくメモ化された値が使用されます

```javascript
import { cache } from 'react'

export const getUser = cache(async (id) => {
  const user = await db.user.findUnique({ id })
  return user
})

getUser(1)
getUser(1) // Called within same render pass: returns memoized result.
```

- フェッチ呼び出しでは、React18 にはキャッシュを使用せずに同様のメカニズムがデフォルトで含まれるようになりました

  - これにより、単一のレンダーパス内のネットワークリクエストの数が減り、アプリケーションのパフォーマンスが向上し、API コストが削減されます

- これらの機能は、Context API にアクセスできないため、React Server コンポーネントで役に立ちます

- キャッシュとフェッチの両方の自動キャッシュ動作によりグローバルモジュールから単一の関数をエクスポートして、アプリケーション全体でそれを再利用できます

```javascript
async function fetchBlogPost(id) {
  const res = await fetch(`/api/posts/${id}`)
  return res.json()
}

async function BlogPostLayout() {
  const post = await fetchBlogPost('123')
  return '...'
}
async function BlogPostContent() {
  const post = await fetchBlogPost('123') // Returns memoized value
  return '...'
}
```

## References

[How React 18 Improves Application Performance](https://vercel.com/blog/how-react-18-improves-application-performance)
