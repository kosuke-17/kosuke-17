# Less code, better UX: Fetching data faster with the Next.js 13 App Router

2023 年 2 月 10 日に投稿された Blog 記事を翻訳しながら、App Router について理解していきます。

## App directory について

- Next.js 13 の App Router を使うとページレベルではなくてコンポーネント内でデータを直接フェチし、重複するコートを大幅に減らすことができる。

  - ↑Pages Router だと、getServerSideProps などの記述をしてページ単位でのデータのフェッチ行う。
  - **server component があれば重複コードが減らせる**
    - ユーザーの名前などをヘッダーに表示させたい場合に、Pages Router だと getServerSideProps でデータを取得して props としてユーザーデータを流さなければいけなかった。表示させたいページ全てでユーザーのデータ取得の記述が必要だった。その重複したコードが App Router では不要になり、Header コンポーネントを Server Component とするとそのコンポーネント内でデータ取得をすることができる。

- **Next.js 13 のカスタムのローディングスケルトンをサーバー側のフェッチ時に持つことができるようになった**
  - サーバーサイドのデータがわたってくるまで静的な UI の生成や LCP(Large Contentful Paint)の表示を待つ必要がなくなった
  - LCP の時間短縮や UX 上のメリットがあるだけでなく、Google 検索で上位に位置するための Core Web Vitals も向上する

---

## Pages Router でのデータフェッチ

Pages Router では 4 つのデータフェッチ手段が存在する

- Server-side renderd(SSR) Data
  - ユーザーが見る前にページをサーバー上で事前レンダリングさせるため使う
  - `getServerSideProps`をページリクエストが発生した時に実行する
  - ページ単位で行うことができる
  - Cache-Control ヘッダーを個別に設定して、設定された間隔でデータをきゃっしゅし UX を高速化することができる
- Static-site generated(SSG) Data
  - 動的なデータを使用するページを事前レンダリングして静的な速度でユーザーに提供したい場合に使われる
  - `getStaticProps`をビルドに時に実行する
  - パブリックにキャッシュできるユーザー固有ではない(CMS などからの)大量のデータに最適
- Incremental statically-generated(ISR) Data
  - 再デプロイをせずにコンテンツを段階的に更新するオプションと、静的ページの生成をビルド時ではなくランライム時に延期するオプションが用意されている
  - `getStaticProps`に revalidate prop を追加するだけで実行される
- Dynamic client-side data

  - クライアントが更新する必要があるデータはページレベル(ページの初期読み込み時)やコンポーネントレベル(コンポーネントのマウント時)でフェッチできます
  - useEffect フックや SWR ライブラリなどをお勧めします。

## App Router ではデータ取得の大幅な改善がありました

- Next.js 13 の App ディレクトリ配下でデフォルトで全てのコンポーネントがサーバーコンポーネントになる
  - これはレイアウト、ページ、個々のコンポーネント内でデータをフェッチすることができるようになったことを意味する
  - それにより定型コードや重複コードを削減して開発時間を節約できるだけでなく、スマートなキャッシュと重複排除、ローディング UI などを用いて高い UX の提供が可能になります

### Server Components

- いつでも サーバー上の Server Components からデータフェッチすることを推奨しています

  - サーバー上で行なわれるためデフォルトで安全になり、クライアントに機密の環境変数がクライアントに漏洩することを防ぎます

- サーバーサイドフェッチとは同じ環境でフェッチとレンダリングを行うことを意味しており、これによりサーバーとクライアントの間のやりとりが減り、メインのクライアントスレッドは他の計算を行うことができます
- クライアントから 1 回 1 回フェッチするのではなく、同じ往復で複数のフェッチを実行できることも意味します。
  - これによりリクエストが並行して解決され、リクエストが互いに重なり合うような不要なウォーターフォールを防ぐことができます。

## Static vs dynamic data

- 動的データはリクエストごとにデータを新たにフェッチする必要があります。一方で静的データは 1 度フェッチしてしまえばキャッシュされたデータをリクエストごとに再利用できます。

- NExt.js13 の新しいデータ取得は fetch(Web API)の上に構築されており、サーバーコンポーネントの async/await を利用します

- getServerSideProps() と getStaticProps() を使用する代わりに、取得したデータはデフォルトで静的です
  - つまりビルド時にレンダリングされます
  - しかし、Next.js のフェッチオプションオブジェクトを拡張して、各リクエストごとに独自のキャッシュと revalidating ルールを設定できます
    - { next: revalidate }オプションを使用すると、設定された間隔で、またはバックエンドでその部分が変更された時に、静的データの任意の部分を変更できます。
    - 頻繁に更新される動的データやユーザーに固有の動的データの場合はフェッチリクエストで{ cache: no-store}オプションを渡すことができます。

## References

[Less code, better UX: Fetching data faster with the Next.js 13 App Router](https://vercel.com/blog/nextjs-app-router-data-fetching)
