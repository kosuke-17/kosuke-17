# Referencing Values with Refs

- コンポーネントが情報を覚えていてほしいが、その情報の変更がトリガーでレンダリングして欲しくない場合に ref を使うことでレンダリングさせることなく情報を取り扱うことができる。

- ref は number だけでなく string,オブジェクトや関数などの値を何でも保持できる。

- 数値の ref の場合に、ref の値が増加してもコンポーネントの再レンダリングは起きない。

- state のように、再レンダリングしても React によって ref の current は保持されたままでいる。つまり、state によって引き起こされる再レンダリング内では ref の値は変化しない。

  - setInterval,clearInterval 関数を用いて開始、ストップ機能のタイマーを実装するときに useRef に ID を保持してストップ機能を実装する。

- 基本的には useState を使い、エスケープハッチとして useRef を使うのが好ましい。

ref と state の違い

- useRef

  - current プロパティを持つオブジェクト({ current: init })を返す
  - 値の変更時の再レンダリングをトリガーしない
  - 可変: current の値をレンダリングプロセスの外で更新できる
    - 同期的に更新する
  - レンダリング中は current の値を読み書きしてはいけない

- useState

  - 状態の値とセッター関数の配列([state, setState])を返す
  - 値の変更時の再レンダリングをトリガーする
  - 不可変: 再レンダリングをキューに入れるために、セッター関数で値を変更する
    - スナップショット(同期的に更新しない)
  - 値をいつでも読める
    - しかし、それぞれのレンダリングは変わらない自身のスナップショットを持つ

- いつ、ref を使う？

  - timeout ID を保持する必要があるとき
  - DOM 要素を保持、操作するとき
  - JSX の計算に必要ないオブジェクト

- ref のベストプラクティス

  - 以下の原則に従うことでコンポーネントを予測可能にさせる
    - エスケープハッチとして扱う
      - 外部システムまたはブラウザ API を操作するときに便利。
      - ロジックとデータフローが ref に依存している場合はアプローチを再構築した方が良い
    - レンダリング中に ref.current を読み書きしない
      - レンダリング中に操作したい場合は useState を使用する
      - なぜなら、React が ref.current の変更を認識しないため、ref.current の値をレンダリング中に読むだけでもコンポーネントがどのような振る舞いをするのか予測するのが難しくなる。
      - `if (!ref.current) ref.current === new Obj()`は唯一の例外(最初のレンダリング中に 1 回だけ設定する)

- useState の state はレンダリングごとにスナップショットのように振る舞い、同期的に値が更新されるような振る舞いはしない。
- ref は一般的な JavaScript Obj であるため、値を同期的に更新するような振る舞いをする。ref を操作するときに avoiding mutation(突然変異)を気にする必要がない。なぜならオブジェクト自身がレンダリングに使用されない限り、React は ref 自身やその中身について認識しないためです。

- ref には任意の値を初期値とするが、多くのユースケースとしては DOM 要素へのアクセスで使用される。
  - JSX の ref 属性に ref を渡す: `<div ref={myRef} />`のようにすると React は対応する DOM 要素を myRef.current にセットする。
    - 要素が DOM から削除されると myRef.current を null に更新する。

## References

[Referencing Values with Refs](https://react.dev/learn/referencing-values-with-refs)
