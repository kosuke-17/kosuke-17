# Chapter1. The Entry-Level Stuff

## Why Is React a Thing?(なぜ React なのか)

- 一言で言い表すなら、更新です

背景

- web の初期の頃は静的なページが溢れていた
  - フォームを記入して、送信し、新たなページ全体を読みこむ
- しばらくはそれでよかった
  - しかし、最終的には web のできることが機能面で大幅に進化した
    要望
- 新たなページのレンダリングや読み込みをすることなく、すぐに更新した内容を見ることができるようにしたかった

  - つまり、Web ページやそれらのページを即時に、よりきびきびと感じさせたかった

- しかし、以下の理由で大規模なアプリでは即時に更新することが厳しかった
  - パフォーマンス
    - web ページを更新することがブラウザにページのレイアウトを再計算(リフロー)させて、描画するトリガーの要因となり、パフォーマンスのボトルネックを発生する原因になっていた。
  - 確実性
    - web アプリで状態を管理することが難しかった
      - 複数人で同じ機能を開発している場合に、複数の場所で状態が一貫しているかを確認する必要があったから
  - セキュリティ
    - クロスサイト スクリプティング (XSS) やクロスサイト リクエスト フォージェリ (CSRF) などのエクスプロイトを防ぐために、ページに挿入するすべての HTML と JavaScript を確実にサニタイズする必要があった

React がこれらの問題をどのように解決するのかを完全に理解するには、React が作られたコンテキストと React が作られる前の世界について知る必要がある

## The World Before React

React の前にあった大きな問題の数々

- 数百万のユーザに使われるときでも安全に安定的に、即時に素早く操作できるようなアプリにしなければいけなかった

- 例えばボタンをクリックする場合を考えてみる

  - ユーザーがボタンをクリックしたときに、ユーザーがボタンを押したことを反映するために UI を更新する
  - その場合に、UI が取りうる 4 つの状態を考慮しなければいけない
    1. Pre-click
       - クリックしていない状態のデフォルトの状態
    2. Clicked but pending
       - クリックしたが、ボタンが実行するはずのアクションが完了しない状態
    3. Clicked and succeeded
       - クリックして、ボタンが実行するアクションが完了する。ここから pre-click 状態に戻ったり、成功を示すための色にボタンを変えたりする
    4. Clicked and failed
       - クリックして、ボタンが実行するアクションが失敗する。ここから pre-click 状態に戻ったり、失敗を示すための色にボタンを変えたりする

- これらの状態を UI に更新させる方法を理解する必要がある

  1. `document.querySelector`や`document.getElementById`のようなブラウザ API を用いてボタンを見つける
  2. クリックイベントを検知するために、ボタンにイベントリスナーをアタッチする
  3. イベントに応じて状態を更新する
  4. ボタンが離れるときにはこのイベントリスナーを取り除いて、状態を削除する

- 例を`/Chapter1_Exp`配下に記載

  - その時代に使われていた `XMLHttpRequest` を用いて、通信するコードを記述した
  - 2015 年には `fetch API` が登場した
  - `XMLHttpRequest`と `fetch API` の間には`$.ajax()`,`$.post()`などの jQuery での通信方法もあった

- 例の実装の通り、ボタンは堅牢になり、複数の状態を扱うことができます。しかし、いくつかの疑問に差し掛かる ⭐️

  - data-pending 属性は本当に必要だったのか。もし、disabled にボタンがなっていても、本当に意図した処理で disabled になっているかはわからない。なぜなら、ログインしていなかったりクリックする権限がないから disabled になっているかもしれないため
  - 多くの他のデータ属性をもつ代わりに、いいねした状態やいいねを外した状態、待ちの状態のようなデータ状態属性を保つことが合理的なのか?
    - そうするためには、大規模な swith/case やそれらを扱うための似たようなコードブロックを追加する必要が出てくる
    - どちらのアプローチも扱うコードの量は膨大になり、それらが複雑さと冗長を生み出してしまう
  - ボタンを単独でテストするにはどうすればいいのか？
  - なぜボタンは 最初に HTML で書かれて、その後に JavaScript で操作するのでしょうか？
    - `createElement("button")`や`appendChild(likeButton)`のように JavaScript でボタンを作成するならばその方が良いではないでしょうか？
    - そうすることで test を容易にできて、自己完結型のコードにさせられる
    - しかし、親が document にない場合は親を追跡する必要がある。実際にはページのすべての親の追跡をし続ける必要がある

- React はこれらの問題を全てではないが解決するのに役立つ

  - 例えば、状態をどのように分割するのかという問題は解決できない
    - isPending や hasFailed などの個別のフラグ、state などの単一の状態変数
    - この問題は React ではなく私たちが答えなければいけない問題なため
    - しかし、規模の問題を解決するのに React は役に立つ
      - インタラクティブであるボタンを多く作成し、最小で効率的な方法でイベントに応じて UI を更新し、testable、再現可能、宣言的、パフォーマンス高く、予測可能に行なってくれる
  - UI の状態を完全に保持し、その状態をもとにレンダリングすることで状態の予測を遥かにしやすくしている
    - これはブラウザによって状態が所有及び操作されることとは対照的です
    - ブラウザの状態はページ上で実行されるクライアントサイド scripts やブラウザ拡張きのう、デバイスの制約 のような他の要因により確実性が大幅に低くなる

- JavaScript は DOM にアクセスすることができる

  - DOM はページの document 構造のインメモリーなモデル
  - ページで要素を表現したオブジェクトのツリーであり、JavaScript 経由でインタラクティブにすることができる
  - ユーザーがどのようなブラウザを使っていて、どのようなネットワーク環境か、何の OS で動いているのかを知る方法はない
    - これらに対して考慮したコードを作成しなければいけない

- アプリケーションの状態をいつ更新するのかを追跡するのは難しい

  - 状態を追跡する状態差分検知メカニズムがなければ

- `item-list.html`に 初期の web アプリケーションで書かれるコードに似せている
  - 時間経過とともにおかしくなっていく
  - なぜか
    - 時間経過とともに拡張することを目的としてアプリケーションを構築していくと以下のことが起こる
  - エラーが発生しやすい
    - どこでいつ removeEventListener を用いてクリーンアップするのか
    - 時間経過とともに多くのイベントリスナーが蓄積されてしまう
    -
  - 予測がししづらくなる
    - リストの items は JavaScript の array で保持されているが、DOM(`id="list-parent"`を持つ要素) での既存の要素に依存している
    - HTML と JavaScript はお互いに依存する関係にあるため、さらにいくつかの点を考慮する必要がある
      - 誤って同じ id を複数の要素が保持していたらどうするのか
      - 要素が全く存在しない場合はどうなるのか
      - ul タグがない場合、li 要素を他の親要素に追加できるか？
      - 代わりにクラス名を使用したらどうなるのか
    - JavaScript と HTML が混在しているソースコードは信頼しにくい
      - 情報源が 1 つのソースコードであれば多くのメリットが得られる
    - いつも client side JavaScript によって DOM から要素が追加されたり、削除されたりする
      - もし、これらの特定の要素に依存している場合、UI は更新され続けるため、アプリが正常に動くことを保証することができない
      - この場合、そのアプリは「副作用」に満ちており、成否はユーザーランドに依存する
      - 副作用を意図的にマークして分離する関数型プログラミングにインスピレーションを受けたモデルを提唱することで、この問題を解決
  - 非効率
    - DOM の更新は計算負荷がかかる
      - 特にレイアウトシフトやリフローなどが関わってくる場合
      - 単一の項目ごとに DOM を順次更新するのではなく、バッチ処理をして一括で DOM の更新を行う方が良いかもしれない
        - しかしエンジニアにとっては価値のないことかもしれない
        - なぜなら、ブラウザは最終的に迅速な更新処理を DOM に行う方法を適用して私たちのために自動でバッチをしてくれるだろうからです
- これらが React やその他の抽象的なものが登場する前から悩まされてきた問題
- 信頼性が高く、スケーラブルな UI を作成するということは当時の多くの企業が苦労していた

- これらの問題を解決するために jQuery や AngularJS のような JavaScript ベースの解決方法の対等してきて、1 つの転換期を迎えた

- それらの解決方法が React とどのように異なっているのかを知ることができます
