# Chapter1. The Entry-Level Stuff

## Why Is React a Thing?(なぜ React なのか)

- 一言で言い表すなら、更新です

背景

- web の初期の頃は静的なページが溢れていた
  - フォームを記入して、送信し、新たなページ全体を読みこむ
- しばらくはそれでよかった
  - しかし、最終的には web のできることが機能面で大幅に進化した
    要望
- 新たなページのレンダリングや読み込みをすることなく、すぐに更新した内容を見ることができるようにしたかった

  - つまり、Web ページやそれらのページを即時に、よりきびきびと感じさせたかった

- しかし、以下の理由で大規模なアプリでは即時に更新することが厳しかった
  - パフォーマンス
    - web ページを更新することがブラウザにページのレイアウトを再計算(リフロー)させて、描画するトリガーの要因となり、パフォーマンスのボトルネックを発生する原因になっていた。
  - 確実性
    - web アプリで状態を管理することが難しかった
      - 複数人で同じ機能を開発している場合に、複数の場所で状態が一貫しているかを確認する必要があったから
  - セキュリティ
    - クロスサイト スクリプティング (XSS) やクロスサイト リクエスト フォージェリ (CSRF) などのエクスプロイトを防ぐために、ページに挿入するすべての HTML と JavaScript を確実にサニタイズする必要があった

React がこれらの問題をどのように解決するのかを完全に理解するには、React が作られたコンテキストと React が作られる前の世界について知る必要がある

## The World Before React

React の前にあった大きな問題の数々

- 数百万のユーザに使われるときでも安全に安定的に、即時に素早く操作できるようなアプリにしなければいけなかった

- 例えばボタンをクリックする場合を考えてみる

  - ユーザーがボタンをクリックしたときに、ユーザーがボタンを押したことを反映するために UI を更新する
  - その場合に、UI が取りうる 4 つの状態を考慮しなければいけない
    1. Pre-click
       - クリックしていない状態のデフォルトの状態
    2. Clicked but pending
       - クリックしたが、ボタンが実行するはずのアクションが完了しない状態
    3. Clicked and succeeded
       - クリックして、ボタンが実行するアクションが完了する。ここから pre-click 状態に戻ったり、成功を示すための色にボタンを変えたりする
    4. Clicked and failed
       - クリックして、ボタンが実行するアクションが失敗する。ここから pre-click 状態に戻ったり、失敗を示すための色にボタンを変えたりする

- これらの状態を UI に更新させる方法を理解する必要がある

  1. `document.querySelector`や`document.getElementById`のようなブラウザ API を用いてボタンを見つける
  2. クリックイベントを検知するために、ボタンにイベントリスナーをアタッチする
  3. イベントに応じて状態を更新する
  4. ボタンが離れるときにはこのイベントリスナーを取り除いて、状態を削除する

- 例を`/Chapter1_Exp`配下に記載

  - その時代に使われていた `XMLHttpRequest` を用いて、通信するコードを記述した
  - 2015 年には `fetch API` が登場した
  - `XMLHttpRequest`と `fetch API` の間には`$.ajax()`,`$.post()`などの jQuery での通信方法もあった

- 例の実装の通り、ボタンは堅牢になり、複数の状態を扱うことができます。しかし、いくつかの疑問に差し掛かる ⭐️

  - data-pending 属性は本当に必要だったのか。もし、disabled にボタンがなっていても、本当に意図した処理で disabled になっているかはわからない。なぜなら、ログインしていなかったりクリックする権限がないから disabled になっているかもしれないため
  - 多くの他のデータ属性をもつ代わりに、いいねした状態やいいねを外した状態、待ちの状態のようなデータ状態属性を保つことが合理的なのか?
    - そうするためには、大規模な swith/case やそれらを扱うための似たようなコードブロックを追加する必要が出てくる
    - どちらのアプローチも扱うコードの量は膨大になり、それらが複雑さと冗長を生み出してしまう
  - ボタンを単独でテストするにはどうすればいいのか？
  - なぜボタンは 最初に HTML で書かれて、その後に JavaScript で操作するのでしょうか？
    - `createElement("button")`や`appendChild(likeButton)`のように JavaScript でボタンを作成するならばその方が良いではないでしょうか？
    - そうすることで test を容易にできて、自己完結型のコードにさせられる
    - しかし、親が document にない場合は親を追跡する必要がある。実際にはページのすべての親の追跡をし続ける必要がある

- React はこれらの問題を全てではないが解決するのに役立つ

  - 例えば、状態をどのように分割するのかという問題は解決できない
    - isPending や hasFailed などの個別のフラグ、state などの単一の状態変数
    - この問題は React ではなく私たちが答えなければいけない問題なため
    - しかし、規模の問題を解決するのに React は役に立つ
      - インタラクティブであるボタンを多く作成し、最小で効率的な方法でイベントに応じて UI を更新し、testable、再現可能、宣言的、パフォーマンス高く、予測可能に行なってくれる
  - UI の状態を完全に保持し、その状態をもとにレンダリングすることで状態の予測を遥かにしやすくしている
    - これはブラウザによって状態が所有及び操作されることとは対照的です
    - ブラウザの状態はページ上で実行されるクライアントサイド scripts やブラウザ拡張きのう、デバイスの制約 のような他の要因により確実性が大幅に低くなる

- JavaScript は DOM にアクセスすることができる

  - DOM はページの document 構造のインメモリーなモデル
  - ページで要素を表現したオブジェクトのツリーであり、JavaScript 経由でインタラクティブにすることができる
  - ユーザーがどのようなブラウザを使っていて、どのようなネットワーク環境か、何の OS で動いているのかを知る方法はない
    - これらに対して考慮したコードを作成しなければいけない

- アプリケーションの状態をいつ更新するのかを追跡するのは難しい

  - 状態を追跡する状態差分検知メカニズムがなければ

- `item-list.html`に 初期の web アプリケーションで書かれるコードに似せている

  - 時間経過とともにおかしくなっていく
  - なぜか
    - 時間経過とともに拡張することを目的としてアプリケーションを構築していくと以下のことが起こる
  - エラーが発生しやすい
    - どこでいつ removeEventListener を用いてクリーンアップするのか
    - 時間経過とともに多くのイベントリスナーが蓄積されてしまう
    -
  - 予測がししづらくなる
    - リストの items は JavaScript の array で保持されているが、DOM(`id="list-parent"`を持つ要素) での既存の要素に依存している
    - HTML と JavaScript はお互いに依存する関係にあるため、さらにいくつかの点を考慮する必要がある
      - 誤って同じ id を複数の要素が保持していたらどうするのか
      - 要素が全く存在しない場合はどうなるのか
      - ul タグがない場合、li 要素を他の親要素に追加できるか？
      - 代わりにクラス名を使用したらどうなるのか
    - JavaScript と HTML が混在しているソースコードは信頼しにくい
      - 情報源が 1 つのソースコードであれば多くのメリットが得られる
    - いつも client side JavaScript によって DOM から要素が追加されたり、削除されたりする
      - もし、これらの特定の要素に依存している場合、UI は更新され続けるため、アプリが正常に動くことを保証することができない
      - この場合、そのアプリは「副作用」に満ちており、成否はユーザーランドに依存する
      - 副作用を意図的にマークして分離する関数型プログラミングにインスピレーションを受けたモデルを提唱することで、この問題を解決
  - 非効率
    - DOM の更新は計算負荷がかかる
      - 特にレイアウトシフトやリフローなどが関わってくる場合
      - 単一の項目ごとに DOM を順次更新するのではなく、バッチ処理をして一括で DOM の更新を行う方が良いかもしれない
        - しかしエンジニアにとっては価値のないことかもしれない
        - なぜなら、ブラウザは最終的に迅速な更新処理を DOM に行う方法を適用して私たちのために自動でバッチをしてくれるだろうからです

- これらが React やその他の抽象的なものが登場する前から悩まされてきた問題
- 信頼性が高く、スケーラブルな UI を作成するということは当時の多くの企業が苦労していた

- これらの問題を解決するために jQuery や AngularJS のような JavaScript ベースの解決方法の対等してきて、1 つの転換期を迎えた
  - それらの解決方法が React とどのように異なっているのかを知ることができます

## jQuery

- React より前のルールを使用して Web でそれら(エラーが発生しやすい
  予測しづらい、非効率)の問題を解決しようとしたのかをみる
  - そうすることで React がなぜ重要なのかを学ぶことができる

<details>
<summary>
likeButton with jQuery
</summary>

```html
<button id="likeButton">いいね</button>
```

```js
$('#likeButton').on('click', function () {
  this.prop('disabled', true)
  fetch('/like', {
    method: 'POST',
    body: JSON.stringigy({ liked: this.text() === 'Like' }),
  })
    .then(() => {
      this.text(this.text() === 'Like' ? 'Liked' : 'Like')
    })
    .catch(() => {
      this.text('Failed')
    })
    .finally(() => {
      this.text('disabled', false)
    })
})
```

</details>

- データを UI にバインドし、このデータバインディングを使用して UI を適切に更新していることがわかる
  - jQuery を使用することで直接 UI を直接操作するのに非常に有効
- jQuery は重い副作用の方法で実行され、常に対話しつつ、自身の制御外で値を更新する

  - 副作用
    - import しているモジュールや取り除いた script の実行を含むコードのどこからでもページの構造に直接そしてグローバルに変更を加えることができること
  - これは予測不可能な振る舞いや複雑なインタラクションに繋がって、追跡が困難になり、ページの一部分の変更が予期せぬ方法で他の部分に影響を与えてしまう事になる
  - 潜在的で構造化されていない操作により、コードのメンテナンスやでバックを困難にする

- モダンなフレームワークは DOM 操作を直接行わずに UI の更新を行うため、構造化して予測可能にする仕組みを提供することでこれらの問題に対照しています
  - 当時は jQuery のコードが一般的でしたが、隣のファイルのコードを推論してテストすることが困難だった

likedButton のテストコードを書いてみる

```js
test('likeButton', () => {
  const $button = $('#likeButton')
  expect($button.text()).toBe('Like')
  $button.trigger('click')
  expect($button.text()).toBe('Liked')
})
```

- このテストの問題は`$('#likeButton')`が null を返すこと

  - なぜなら、テスト環境がリアルなブラウザではないから
  - jQuery はブラウザ環境とは独立しており、テストするためにはブラウザと同等の環境を用意しなければいけなくなる(大変)
  - jQuery は単なるゲストであり、「一方向のデータフロー」パラダイムからの逸脱は当時のライブラリではよく見られた問題だった

- jQuery の人気は失われ始めた
  - Web が進化して、より堅牢でスケーラブルな解決方法の必要性が高まったため
- ただ jQuery はまだ多くのアプリで使われているが、現代の Web アプリを作る上での解決策ではなくなった

【セルフメモ】

- jQuery は直接 DOM を行い UI の更新を行なっていた

  - 以下の問題があった
    - テストの記述が困難
    - いつどこからでも、どの DOM にもアクセスできるので、予期せぬ DOM の更新をしてしまう
    - 「単一方向のデータフロー」パラダイムからの逸脱

### なぜ jQuery の人気がなくなったのか

- Weight and load times
- Redundancy with modern browsers
- Performance considerations

## Enter React

<!-- Reactが存在するに至る文脈が書かれている -->

### React's Value Proposition

- JavaScript は Web アプリがスケールすると安全ではなく、予測不可能で、非効率的な状態に陥ることが(jQuery などで)わかっていたため、それを成功に導く解決策が必要だった

1. Declarative versers imperative code (宣言的と命令的)

- React は DOM 上で宣言的な抽象化を提供する
  - つまり、React は見たいものを表現するコードを書く方法を提供しており、それがどのように起こるのかを管理し、UI が作成されて安全に、予測可能かつ効率的な方法で動作するのかを保証している
  - コンポーネントの役割は UI がどのような見た目なのかの記述を返すだけ
    - 仮想 DOM を使用することで実現する
      - 仮想 DOM とは、意図した UI 構造を軽量に記述したもの
    - React は仮想 DOM の更新前と更新後を比較して、実際の DOM を仮想 DOM と一致させるために小さな高パフォーマンスの高い更新に変える

2. The virtual DOM

- virtual DOM は実際の DOM を表現するためのプログラミングコンセプトである
- ここで大事なのは、仮想 DOM は直接的に実際の DOM を操作せずに UI の更新を行うことを理解しておくことである
- React は仮想 DOM を使ってコンポーネントの変更を検知し、必要な時だけコンポーネントを再レンダリングする
  - このアプローチは変更があるたびに DOM ツリー全体を更新するよりも高速で効率的
- React では、仮想 DOM は実際の DOM ツリーを軽量に表現したもの
  - これは UI 要素の構造とプロパティを記述するプレーンな JavaScript オブジェクトである
  - 実際の DOM ツリーと一致するように仮想 DOM を作成、更新し、仮想 DOM に加えられた変更は reconciliation(差分検知処理)と呼ばれるプロセスを使い実際の DOM に適用される

```js
// いいねボタンといいねの数を表示するコンポーネント
import React, { useState } from "react";

function LikeButton() {
  const [likes, setLikes] = useState(0);

  function handleLike() {
    setLikes(likes   1);
  }

  return (
    <div>
      <button onClick={handleLike}>Like</button>
      <p>{likes} Likes</p>
    </div>
  );
}

export default LikeButton;
```

```js
// 最初のレンダリングで作成されるいいねボタンの仮想DOMのtree
{
  $$typeof: Symbol.for('react.element'),
  type: 'div',
  props: {},
  children: [
    {
      $$typeof: Symbol.for('react.element'),
      type: 'button',
      props: { onClick: handleLike },
      children: ['Like']
    },
    {
      $$typeof: Symbol.for('react.element'),
      type: 'p',
      props: {},
      children: [0, ' Likes']
    }
  ]
}
```

```js
// いいねをした時に作成される仮想DOMのtree
{
  type: 'div',
  props: {},
  children: [
    {
      type: 'button',
      props: { onClick: handleLike },
      children: ['Like']
    },
    {
      type: 'p',
      props: {},
      children: [1, ' Likes'] // ここの0が1に変化している
    }
  ]
}
```

- 差分検知処理によって新たな tree と古い tree の違いを理解する

  - 更新される必要がある実際の DOM はどこにあたるのかを決定する

- React は新しい vDOM の状態を DOM と整合させるために実際の DOM で行う最小限の効率的な更新セット(処理方法?)を計算し、最終的に仮想 DOM に加えられた変更を反映させるために実際の DOM を更新する

- React は実際の DOM 操作を必要な箇所のみ更新することで、DOM 操作の回数を最小限に抑えている ⭐️

  - このアプローチは全体の DOM を変更があるたびに更新するアプローチよりもはるかに高速で効率的である

- 仮想 DOM は現代の Web にとって強力で影響力のある発明であり、Preact や Inferno のようなライブラリが採用している

3. The component model⭐️

- component model は React のキーコンセプトで"thinking in components"を高く推奨している
  - コンポーネントとして分割しておくことで、どこでも再利用可能で分割元を直すだけで全ての使用先の修正が可能になる(DRY の原則と同じコンセプト)
- React はコンポーネントの追跡し、メモ化、バッチ処理、他の最適化のようなパフォーマンスマジックを用意に実行できる
  - 特定のコンポーネントを何度も識別し、時系列で特定のコンポーネントの更新を追跡することができれば
  - これを keying という
- 関心の分離を助けてくれて、ロジックが影響を与える UI の部分に近いロジックを配置する

  - LikeButton コンポーネントがある場合、いいねのロジックをこのコンポーネントに配置して、UI は新たに Button コンポーネントを作成します。そうすることで LikeButton コンポーネントはロジックの処理を扱う役割を持ちます。これを Composition(コンポジション)という

- component model は基礎的なコンセプトであり、開発に多くの利益をもたらし、モジュール性を高めて、デバックを容易にさせ、コードの再利用を効率良くする

4. Immutable State

- React の設計思想はアプリケーションの状態を不変の値の集合として記述するパラダイムを重視している

  - 各状態の更新は個別のスナップショットとメモリ参照として扱われる
  - 状態管理に対するイミュータブルなアプローチは React の価値提案の核となる部分であり、堅牢で効率的かつ予測的な UI を開発する上でいくつかの利点がある

- 不変を強制することで、React は UI components が任意の時点で特定の状態を反映していることを保証する

  - 状態が変更した時には、直接変異するのではなく、新たな状態を表す新しいオブジェクトを返す
  - これにより変更の追跡やデバック、アプリが振る舞う動作の理解がしやすくなる
  - 状態遷移は離散しており、お互いに干渉しないので、共有された変更可能な状態によって引き起こされる微妙なバグが発生する可能性は大幅に減少する

- 開発者が機能的にデータフローについて考えることを促し、副作用を減らし、コードをたどりやすくする

  - 不変なデータフローを明確にすることで、アプリがどのように動作するのかを理解するためのメンタルモデルが単純化される ⭐️

- React の不変な状態更新へのコミットメントは多くの利点をもたらす意図的な設計上の選択である
  - 現代の関数型プログラミングの原則に従い、効率的な UI の更新を可能にし、パフォーマンスを最適化し、バグの可能性を減らし、開発者の全体的な体験を向上させる
  - 状態管理に対するこのアプローチは多くの React の先進的な機能を多く支えており、React が進化するにつれて今後も礎であり続けるだろう

### Releasing React

- 単一方向のデータフローは長年作成してきた Web アプリを構築してきた中でも根本的に異なるものであり、懐疑的な目で見られていた
- Facebook は多くのリソースやユーザー、エンジニアを抱える大きな会社なので、道のりは険しかった。その後に多くの精査を受けて、React は社内で成功し、Facebook と Instagram で採用された

- React は 2013 年にオープンソース化されて、世界中にリリースされて多くの反響を得た

  - 中でも React が JSX を用いることを「JavaScript に HTML を入れた」「関心の分離を壊した」と非難を浴びた
  - 最終的には Nexflix や Airbnb などの企業がが React を de facto standard として使用す流用になった
  - いくつかの詳細な説明はこの本のスコープ外のため、割愛した。ただ、作成された React が解決する技術的な問題の詳細に入る前に React の背景を知るのは重要である
  - React の歴史に興味がある人は React.js: The Documentary by Honeypot を見ると良い

- React がオープンソース化された後に Flux というデータフロー管理パターンを提唱した
  - Flux: 大規模アプリでデータフロー管理の挑戦かつ React エコシステムの一部への回答だった

### The Flux Architexture

- Flux とは、Facebook によって広められて、クライアントサイド Web アプリを構築するための設計パターンである

  - 単一方向のデータフロー
    - データの流れをアプリ内でより予測可能にする

- the key concepts of Flux architecture

  - Actions
    - 新たなデータや識別している type property を含むシンプルなオブジェクト
    - 中央の Dispatcher を通じて、さまざまな store に dispatch される
    - `{ type: "ADD_TODO", text: "learn Flux Architecture" }`
  - Dispatcher
    - Flux Architecture のハブの役割をになっている
    - action を受け取り、登録されている stores にそれを送る
    - コールバックのリストを管理しており、すべてのストアは自身とコールバックを dispatcher に登録する
    - アクションが dispatch されると、すべての登録されているコールバックに送られる
  - Stores
    - アプリの状態とロジックを含める
    - MVC アーキテクチャでのモデルに似たもの
    - 多くのオブジェクトの状態を管理する
    - dispatcher を登録して、アクションを行うコールバックを提供する
  - Views
    - React Components のこと
    - Store からの変更イベントをリッスンして、データがその変更に依存している時に自分自身を更新する

- Flux Architecture はシステムの一方向のデータフローを促進させる
  - 時間の経過とともに、変更の追跡を行いやすくしてくれる

### Benefits of the Flux Architecture

- Flux Architecture は多様な利益をもたらす

  - Single source of truth(信頼できる唯一の情報源)
    - アプリの状態を唯一の情報源で管理することを重要視している
    - このように状態を一元管理することで、アプリケーションの振る舞いを予測可能にして理解しやすくする
    - 複数の依存する情報源があるとバグやアプリケーション全体の不整合が起きてしまうため、それらをない状態にすることができる
  - Testability
    - 良く定義されている構造や予測可能なデータフローがテスト可用性を高くする
    - システムの異なる部分の間(actions, dispatcher, stores, views)で関心の分離を行うことができるため、それぞれで独立して単体テストを行うことができる
    - データフローが一方向であったり、状態が特定の場所に保存されている場合は、テストを書くことが容易になる
  - Separation of concerns(SoC)
    - コードを記述する段階で、システムの異なる関心を明らかに分離している
    - この分離はシステムのモジュール化やメンテナンス性を容易にしたり、推論も容易になる
    - それぞれのパートは明確に定義された役割があり、一方向のデータフローによってどのようにそれらのパーツが相互作用するかが明確になる
