# 第 6 章 データ取得とキャッシュ

- Web フロントエンドの開発対象は UI コンポーネントだが、Next.js のような Web アプリケーションサーバーと開発対象とする場合、サーバーサイドの処理も開発対象となる
  - Web アプリケーションサーバーの責務
    - 外部システムからデータを取得して表示すること
    - UI 入力値を受付けて、データ更新リクエストを送ること

## 6.1 サンプルコード共通の UI コンポーネント

- Storybook: プロジェクトにコミットされた UI コンポーネント一覧をブラウザで確認できる「UI コンポーネントエクスプローラー」のうちの一つ

- モノレポ構成する workspaces 部が Next.js プロジェクトがそれぞれ格納されている

applications/package.json

```json
{
  "workspaces": [
    "packages/sns-api-1",
    "packages/sns-shared-ui",
    "packages/sns-web-1",
    "packages/sns-web-2",
    "packages/sns-web-3"
  ]
}
```

使用する側の sns-web-1 に sns-shared-ui が dependencies に含まれている
applications/packages/sns-web-1/package.json

```json
{
  "dependencies": [
    // ...
    { "sns-shared-ui": "*" }
  ]
}
```

Next.js ではトランスパイルして使用するために transpilePackage オプションを記述
applications/packages/sns-web-1/next.config.mjs

```js
const nextConfig = {
  // ...
  transpilePackages: ['sns-shared-ui'],
}
```

こうすることで sns-shared-ui からコンポーネントを import して使用できる
`import { HeadeGroup } from "sns-shared-ui/src/components/HeadeGroup"`

複数の Next.js プロジェクトで構成されている場合はライブラリ化することが効果的

## 6.2 fetch 関数でのデータ取得

- src/services : Web API クライアントの一覧
  - fetch 関数は Promise を返すが、400 以上のステータスコードでも Promise が reject されない
  - そのため、then の中で`!res.ok`の場合に throw new FetchError を返す必要がある

```js
export async function getCategory(
  {
    // ...
  }
) {
  //...
  return fetch(path(`/api/categories/${categoryName}?${searchParams}`), {
    cache: 'no-store',
    next: { tags: ['categories'] },
  })
    .then(handleSucceed) // ここ重要
    .catch(handleFailed)
}

xport const handleSucceed = async (res: Response) => {
  const data = await res.json();
  if (!res.ok) {
    throw new FetchError(res.statusText, res.status);
  }
  return data;
};

export const handleFailed = async (err: unknown) => {
  if (err instanceof FetchError) {
    console.warn(err.message);
  }
  throw err;
};

```

## 6.3 fetch 関数の Request のメモ化

- Request のメモ化 : 同じ fetch 関数のリクエストは、自動で 1 つの fetch 関数リクエストにまとめる(React が拡張)
  - **パラメータが異なっているとメモ化は行われないので、同じにする必要がある**
    - オブジェクトを渡すと、渡すたびにオブジェクトは異なるのでメモ化が行われない
    - string や number などプリミティブな値を引数にする必要がある
- 1 回のレンダリングで同じデータ取得を行いたいケースはよくある
  - Request のメモ化を怠ると過剰なデータソースへのアクセスとなり、パーフォマンス低下の原因となる

```js
// 異なる引数 : メモ化が行われない
const data = await getCategory({ categoryName })
const data = await getCategory({ categoryName, page, take })

// 引数を同じにする(props)
// generateMetadata と Page で引数の異なる fetch 関数を呼び出さないよう注意
async function getCategoryFromProps({ params }: Props) {
  // ...
  const data = await getCategory({
    categoryName,
    page,
    take: `${take}`,
  })
  return { ...data, page: +page }
}
export async function generateMetadata(props: Props): Promise<Metadata> {
  const data = await getCategoryFromProps(props)
  return { title: `${data.category.label}の写真一覧 | ${SITE_NAME}` }
}

export default async function Page(props: Props) {
  const data = await getCategoryFromProps(props)

  // ...
}
```

## 6.4 fetch 関数のキャッシュ

### 6.4.1 Time-based Revalidation

- fetch 関数に rebalidate を渡して、キャッシュを指定時間過ぎたら削除して新しいキャッシュを作成する
  - Incremental Cache : データ取得結果をキャッシュし、必要に応じて更新するメカニズム
  - このキャッシュ機構がデフォルトで true になっている
    - App Router: fetch 関数による Data キャッシュ
      - `fetch(https:/...)` : １年間キャッシュ(デフォルト)
      - `fetch(https:/..., { next: { revalidate: 60 * 60 }})`: 1 時間キャッシュ(revalidate で秒単位の指定)
- Time-based Revalidation: next.revalidate オプションのように有効期間で指定する Revalidate のこと

  - Revalidate(再検証): キャッシュを更新するプロセス

- キャッシュを活用することで、API サーバーへのアクセス頻度を削減できる

```js
export function getPhotos({
  page = '1',
  take = '10',
  authorId,
  revalidate,
}: Props): Promise<{ photos: Photo[], pagination: PaginationProps }> {
  const searchParams = new URLSearchParams({
    page,
    take,
    ...(authorId && { authorId }),
  })
  return fetch(path(`/api/photos?${searchParams}`), {
    next: {
      ...(authorId && { tags: [`photos?authorId=${authorId}`] }),
      ...(revalidate !== undefined && { revalidate }),
    },
  })
    .then(handleSucceed)
    .catch(handleFailed)
}
```
