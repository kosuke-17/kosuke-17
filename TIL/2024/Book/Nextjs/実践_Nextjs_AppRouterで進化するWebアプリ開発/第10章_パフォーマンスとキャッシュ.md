# 第 10 章 パフォーマンスとキャッシュ

## 10.1 コンポーネント構造のパフォーマンスへの影響

- Pages Router では、getStaticProps や getServerSideProps で Route ごとに取得していた
- App Router では、Server Component であればどこでもデータ取得できる

複数データを取得する際にはページ単位で取得する際に fetch 処理を 1 つのページで行わないといけなかった。

- App Router ではそれらの取得処理をコンポーネントの中で行う
- 直列でデータ取得を行うのではなく、それを回避するために Promise.all で並列取得するのではく、Server Component ごとに取得することで並列取得をしている

- コンポーネントが必要とするデータをコンポーネント自身が取得することをコロケーションするという

## 10.2 fetchCache の設定

キャッシュ指定しても、キャッシュされない場合は動的関数を使用していることをキャッチしている場合がある

- `{cache: force-cache }`することで強制的に静的にさせてキャッシュできるようにする

## 10.3 静的 Route を増やす方法

- 意図ぜずに動的 Route に変わってしまうケース

  - layout.tsx に getServerSessions などの動的関数を使用していると、その Route 以下の子 Route も動的 Route と判断されてしまう

- コンポーネントツリーの Root 付近で動的関数を使用するのには注意が必要

## 10.4 SSG Route の実装

- SSG Route: ビルド時にあらかじめ Route のレンダリング結果を出力しておく SSG

  - 静的 Route に対し、html,meta,rsc が出力されているまとまりを Full Route キャッシュという
  - SSG はビルド時だけでなく、リクエスト時にも起こる
  - npm run dev などローカル開発環境では正しく検証できない(ビルド時と next start で起動している時のみ、正しく検証できる)

- Dynamic Route で generateStaticParams 関数を使用することで SSG Route ができる

  - generateStaticParams: ビルド時にしか実行されない
  - 指定した生成対象以外のパスの場合はビルド時ではなく、リクエスト時に SSG が生成される
  - 存在しない値を指定しても 404 ページが無駄に作成されてしまう

- searchParams を参照すると動的 Route となり、SSG Route 化できない
  - そのため、URL 設計が必要になる
  - × : categories/[categoryName], `/category/flower?page=1`,`/category/flower?page=2`
  - ○ : categiries/[...segments], `/category/flower`, `/category/flower/1`,`/category/flower/2`
